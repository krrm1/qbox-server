var T=e=>{throw TypeError(e)};var R=(e,t,r)=>t.has(e)||T("Cannot "+r);var s=(e,t,r)=>(R(e,t,"read from private field"),r?r.call(e):t.get(e)),d=(e,t,r)=>t.has(e)?T("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r),f=(e,t,r,a)=>(R(e,t,"write to private field"),a?a.call(e,r):t.set(e,r),r);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))a(o);new MutationObserver(o=>{for(const i of o)if(i.type==="childList")for(const c of i.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&a(c)}).observe(document,{childList:!0,subtree:!0});function r(o){const i={};return o.integrity&&(i.integrity=o.integrity),o.referrerPolicy&&(i.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?i.credentials="include":o.crossOrigin==="anonymous"?i.credentials="omit":i.credentials="same-origin",i}function a(o){if(o.ep)return;o.ep=!0;const i=r(o);fetch(o.href,i)}})();var A=`
  attribute vec2 a_position;
  attribute vec2 a_texcoord;
  uniform mat3 u_matrix;
  varying vec2 textureCoordinate;
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    textureCoordinate = a_texcoord;
  }
`,g=`
varying highp vec2 textureCoordinate;
uniform sampler2D external_texture;
void main()
{
  gl_FragColor = texture2D(external_texture, textureCoordinate);
}
`;function m(e,t,r){let a=e.createShader(t);if(!a)throw new Error("Failed to create shader");e.shaderSource(a,r),e.compileShader(a);let o=e.getShaderInfoLog(a);return o&&console.error(o),a}function p(e){let t=e.createTexture(),r=new Uint8Array([0,0,255,255]);return e.bindTexture(e.TEXTURE_2D,t),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,1,1,0,e.RGBA,e.UNSIGNED_BYTE,r),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.MIRRORED_REPEAT),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT),e.texParameterf(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),t}function v(e){let t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,1,1]),e.STATIC_DRAW);let r=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,1,1]),e.STATIC_DRAW),{vertexBuff:t,texBuff:r}}function w(e){let t=m(e,e.VERTEX_SHADER,A),r=m(e,e.FRAGMENT_SHADER,g),a=e.createProgram();if(!a)throw new Error("Failed to create program");e.attachShader(a,t),e.attachShader(a,r),e.linkProgram(a),e.useProgram(a);let o=e.getAttribLocation(a,"a_position"),i=e.getAttribLocation(a,"a_texcoord");return{program:a,vloc:o,tloc:i}}function x(e){let t=e.getContext("webgl",{antialias:!1,depth:!1,stencil:!1,alpha:!1,desynchronized:!0,failIfMajorPerformanceCaveat:!1}),r=()=>{};function a(){let i=p(t),{program:c,vloc:u,tloc:E}=w(t),{vertexBuff:h,texBuff:_}=v(t);t.useProgram(c),t.bindTexture(t.TEXTURE_2D,i),t.uniform1i(t.getUniformLocation(c,"external_texture"),0),t.bindBuffer(t.ARRAY_BUFFER,h),t.vertexAttribPointer(u,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(u),t.bindBuffer(t.ARRAY_BUFFER,_),t.vertexAttribPointer(E,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(E),t.viewport(0,0,t.canvas.width,t.canvas.height),r()}let o={canvas:e,gl:t,animationFrame:void 0,resize:(i,c)=>{t.viewport(0,0,i,c),t.canvas.width=i,t.canvas.height=c}};return r=()=>{t.drawArrays(t.TRIANGLE_STRIP,0,4),t.finish(),o.animationFrame=requestAnimationFrame(r)},a(),o}var l,n;class P{constructor(){d(this,l);d(this,n,null)}start(){window.addEventListener("message",async t=>{const r=t.data;r.action==="capture"&&await this.captureScreen(r)}),window.addEventListener("resize",()=>{s(this,l)&&s(this,l).resize(window.innerWidth,window.innerHeight)})}async captureScreen(t){f(this,n,document.createElement("canvas")),s(this,n).width=window.innerWidth,s(this,n).height=window.innerHeight,f(this,l,x(s(this,n)));const r=t.encoding??"png";let a;if(t.serverEndpoint||!t.formField?a=await this.createBlob(s(this,n),r):a=await this.createBlob(s(this,n),r),!a)return console.error("No image available");console.log("Image data:",a),console.log("image size:",a.size),await this.httpUploadImage(t,a),s(this,n).remove()}async httpUploadImage(t,r){const a=this.createRequestBody(t,r);if(t.serverEndpoint)try{await fetch(t.serverEndpoint,{method:"POST",mode:"cors",headers:{"X-ScreenCapture-Token":t.uploadToken},body:a})}catch(o){console.error(o)}}createRequestBody(t,r){if(r instanceof Blob){const a=new FormData;return a.append(t.formField??"file",r),a}return JSON.stringify({imageData:r,dataType:t.dataType})}createDataURL(t){return new Promise((r,a)=>{const o=t.toDataURL("image/webp",.7);o||a("No data URL available"),r(o)})}createBlob(t,r){return new Promise((a,o)=>{t.toBlob(i=>{i?a(i):o("No blob available")},`image/${r}`,.7)})}}l=new WeakMap,n=new WeakMap;const b=new P;b.start();
